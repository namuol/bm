// Generated by CoffeeScript 1.8.0
(function() {
  var create,
    __slice = [].slice;

  create = function(size) {
    var Mask, Multimask, bm, count, maskData, masks, stringArray, tags, uint32ArrayToString, uint32count, zeroMaskData;
    if (size == null) {
      size = 31;
    }
    tags = {};
    count = 0;
    masks = {};
    uint32count = Math.ceil(size / 31);
    if (uint32count <= 1) {
      Mask = (function() {
        function Mask(_val) {
          this._val = _val;
          this._str = this._val.toString();
        }

        Mask.prototype.toString = function() {
          return this._str;
        };

        Mask.prototype.has = function(other) {
          return (this._val & other._val) === other._val;
        };

        Mask.prototype.any = function(other) {
          return !!(this._val & other._val);
        };

        Mask.prototype.and = function(other) {
          var val, _ref;
          val = this._val | other._val;
          return (_ref = masks[val]) != null ? _ref : (masks[val] = new Mask(val));
        };

        Mask.prototype.not = function(other) {
          var val, _ref;
          val = this._val & ~other._val;
          return (_ref = masks[val]) != null ? _ref : (masks[val] = new Mask(val));
        };

        return Mask;

      })();
      bm = function() {
        var arg, args, val, _i, _len, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        val = 0;
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (tags[arg] == null) {
            tags[arg] = count;
            count += 1;
          }
          val |= Math.pow(2, tags[arg]);
        }
        return (_ref = masks[val]) != null ? _ref : (masks[val] = new Mask(val));
      };
    } else {
      stringArray = new Array(uint32count);
      uint32ArrayToString = function(arr) {
        var i, num, _i, _len;
        for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
          num = arr[i];
          stringArray[i] = num.toString(36);
        }
        return stringArray.join('.');
      };
      zeroMaskData = new Uint32Array(uint32count);
      maskData = new Uint32Array(uint32count);
      Multimask = (function() {
        function Multimask(_val, _str) {
          this._val = _val;
          this._str = _str;
        }

        Multimask.prototype.toString = function() {
          return this._str;
        };

        Multimask.prototype.has = function(other) {
          var idx, otherVal;
          idx = 0;
          while (idx < this._val.length) {
            otherVal = other._val[idx];
            if (!((this._val[idx] & otherVal) === otherVal)) {
              return false;
            }
            idx += 1;
          }
          return true;
        };

        Multimask.prototype.any = function(other) {
          var idx, otherVal;
          idx = 0;
          while (idx < this._val.length) {
            otherVal = other._val[idx];
            if (this._val[idx] & otherVal) {
              return true;
            }
            idx += 1;
          }
          return false;
        };

        Multimask.prototype.and = function(other) {
          var idx, key, _ref;
          maskData.set(this._val);
          idx = 0;
          while (idx < this._val.length) {
            maskData[idx] |= other._val[idx];
            idx += 1;
          }
          key = uint32ArrayToString(maskData);
          return (_ref = masks[key]) != null ? _ref : (masks[key] = new Multimask(new Uint32Array(maskData), key));
        };

        Multimask.prototype.not = function(other) {
          var idx, key, _ref;
          maskData.set(this._val);
          idx = 0;
          while (idx < this._val.length) {
            maskData[idx] &= ~other._val[idx];
            idx += 1;
          }
          key = uint32ArrayToString(maskData);
          return (_ref = masks[key]) != null ? _ref : (masks[key] = new Multimask(new Uint32Array(maskData), key));
        };

        return Multimask;

      })();
      bm = function() {
        var arg, args, bitidx, key, _i, _len, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        maskData.set(zeroMaskData);
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (tags[arg] == null) {
            tags[arg] = count;
            count += 1;
          }
          bitidx = tags[arg];
          maskData[Math.ceil((bitidx + 1) / 32) - 1] |= Math.pow(2, bitidx % 32);
        }
        key = uint32ArrayToString(maskData);
        return (_ref = masks[key]) != null ? _ref : (masks[key] = new Multimask(new Uint32Array(maskData), key));
      };
    }
    return bm;
  };

  module.exports = create;

}).call(this);
